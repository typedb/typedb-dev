#!/usr/bin/env bash
set -euo pipefail

# TypeDB Multi-Repo Orchestration Tool
# Human-readable output for branch management across submodules

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
REPOS_DIR="$ROOT_DIR/repositories"
REMOTE_NAME="typedb"

# All known submodules
ALL_REPOS=(
  typedb
  typedb-driver
  typeql
  typedb-protocol
  typedb-console
  typedb-studio
  typedb-cluster
  typedb-cloud
  typedb-cloud-infrastructure
  dependencies
  bazel-distribution
  typedb-behaviour
  typedb-docs
  typedb-examples
  typedb-web
)

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Check if we're in a TTY for color support
if [ -t 1 ]; then
  USE_COLOR=true
else
  USE_COLOR=false
fi

color() {
  if [ "$USE_COLOR" = true ]; then
    echo -e "$1$2${NC}"
  else
    echo "$2"
  fi
}

# Validate repo exists as submodule
validate_repo() {
  local repo="$1"
  local repo_path="$REPOS_DIR/$repo"
  if [ ! -d "$repo_path/.git" ] && [ ! -f "$repo_path/.git" ]; then
    return 1
  fi
  return 0
}

# Get current branch of a repo
get_branch() {
  local repo="$1"
  git -C "$REPOS_DIR/$repo" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "HEAD"
}

# Check if repo has uncommitted changes
is_clean() {
  local repo="$1"
  if git -C "$REPOS_DIR/$repo" diff --quiet 2>/dev/null && git -C "$REPOS_DIR/$repo" diff --cached --quiet 2>/dev/null; then
    return 0
  else
    return 1
  fi
}

# Get ahead/behind counts
get_ahead_behind() {
  local repo="$1"
  local branch
  branch=$(get_branch "$repo")
  if [ "$branch" = "HEAD" ]; then
    echo "0 0"
    return
  fi
  local upstream="$REMOTE_NAME/$branch"
  if ! git -C "$REPOS_DIR/$repo" rev-parse "$upstream" &>/dev/null; then
    echo "0 0"
    return
  fi
  local counts
  counts=$(git -C "$REPOS_DIR/$repo" rev-list --left-right --count "$branch...$upstream" 2>/dev/null || echo "0 0")
  echo "$counts"
}

# Get modified file count
get_modified_count() {
  local repo="$1"
  git -C "$REPOS_DIR/$repo" status --porcelain 2>/dev/null | wc -l | tr -d ' '
}

# Get base branch for a repo from its CLAUDE.md, or return default
get_base_branch() {
  local repo="$1"
  local claude_md="$REPOS_DIR/$repo/CLAUDE.md"
  local base_branch="master"

  if [ -f "$claude_md" ]; then
    # Look for "Base branch:" pattern in CLAUDE.md (handles markdown formatting like **bold** and `backticks`)
    local line
    line=$(grep -iE "(base[_ ]?branch)\s*\**\s*:" "$claude_md" 2>/dev/null | head -1)
    if [ -n "$line" ]; then
      # Extract value between backticks, or after colon if no backticks
      local found_branch
      found_branch=$(echo "$line" | grep -o '`[^`]*`' | head -1 | tr -d '`')
      if [ -z "$found_branch" ]; then
        # No backticks, try to get word after colon
        found_branch=$(echo "$line" | sed 's/.*://' | tr -d '[:space:]' | head -1)
      fi
      if [ -n "$found_branch" ]; then
        base_branch="$found_branch"
      fi
    fi
  fi

  echo "$base_branch"
}

# Get GitHub username
get_github_username() {
  # Try gh CLI first
  if command -v gh &>/dev/null; then
    gh api user -q .login 2>/dev/null && return
  fi
  # Fall back to git config
  git config --get github.user 2>/dev/null
}

# Command: init
# Initialize submodules and configure remotes
cmd_init() {
  local repos=("$@")

  echo "Initializing TypeDB development environment"
  echo ""

  # If no repos specified, init all
  if [ ${#repos[@]} -eq 0 ]; then
    echo "Initializing all submodules..."
    git -C "$ROOT_DIR" submodule update --init
    echo ""
    repos=("${ALL_REPOS[@]}")
  else
    echo "Initializing specified submodules..."
    for repo in "${repos[@]}"; do
      git -C "$ROOT_DIR" submodule update --init "repositories/$repo" 2>/dev/null || true
    done
    echo ""
  fi

  echo "Configuring remotes (origin -> typedb)..."
  echo ""

  for repo in "${repos[@]}"; do
    local repo_path="$REPOS_DIR/$repo"

    if [ ! -d "$repo_path" ] || { [ ! -d "$repo_path/.git" ] && [ ! -f "$repo_path/.git" ]; }; then
      color "$YELLOW" "  - $repo - not initialized (may not have access)"
      continue
    fi

    # Check if 'typedb' remote already exists
    if git -C "$repo_path" remote get-url "$REMOTE_NAME" &>/dev/null; then
      color "$BLUE" "  ● $repo - remote '$REMOTE_NAME' already configured"
    elif git -C "$repo_path" remote get-url origin &>/dev/null; then
      git -C "$repo_path" remote rename origin "$REMOTE_NAME" 2>/dev/null
      color "$GREEN" "  ✓ $repo - renamed origin to $REMOTE_NAME"
    else
      color "$YELLOW" "  - $repo - no remote to configure"
    fi
  done

  echo ""

  # Add user's fork as remote
  local github_user
  github_user=$(get_github_username)

  if [ -z "$github_user" ]; then
    echo "Skipping fork remote setup (GitHub username not found)"
    echo "To configure, run: gh auth login  OR  git config --global github.user <username>"
  else
    echo "Adding fork remotes for user: $github_user"
    echo ""

    for repo in "${repos[@]}"; do
      local repo_path="$REPOS_DIR/$repo"

      if [ ! -d "$repo_path" ] || { [ ! -d "$repo_path/.git" ] && [ ! -f "$repo_path/.git" ]; }; then
        continue
      fi

      # Check if user remote already exists
      if git -C "$repo_path" remote get-url "$github_user" &>/dev/null; then
        color "$BLUE" "  ● $repo - remote '$github_user' already configured"
      else
        local fork_url="git@github.com:$github_user/$repo.git"
        if git -C "$repo_path" remote add "$github_user" "$fork_url" 2>/dev/null; then
          color "$GREEN" "  ✓ $repo - added remote '$github_user'"
        else
          color "$RED" "  ✗ $repo - failed to add remote '$github_user'"
        fi
      fi
    done
  fi

  echo ""

  # Fetch latest and checkout base branch for each repo
  echo "Fetching latest and checking out base branches..."
  echo ""

  for repo in "${repos[@]}"; do
    local repo_path="$REPOS_DIR/$repo"

    if [ ! -d "$repo_path" ] || { [ ! -d "$repo_path/.git" ] && [ ! -f "$repo_path/.git" ]; }; then
      continue
    fi

    local base_branch
    base_branch=$(get_base_branch "$repo")

    # Fetch the base branch from typedb remote
    if ! git -C "$repo_path" fetch "$REMOTE_NAME" "$base_branch" &>/dev/null; then
      color "$YELLOW" "  - $repo - failed to fetch $REMOTE_NAME/$base_branch"
      continue
    fi

    # Checkout the base branch and reset to remote
    if git -C "$repo_path" checkout "$base_branch" &>/dev/null 2>&1; then
      if git -C "$repo_path" reset --hard "$REMOTE_NAME/$base_branch" &>/dev/null; then
        color "$GREEN" "  ✓ $repo - on $base_branch (synced with $REMOTE_NAME)"
      else
        color "$YELLOW" "  - $repo - on $base_branch (could not sync)"
      fi
    else
      # Branch might not exist locally yet, create it tracking remote
      if git -C "$repo_path" checkout -b "$base_branch" "$REMOTE_NAME/$base_branch" &>/dev/null 2>&1; then
        color "$GREEN" "  ✓ $repo - created $base_branch from $REMOTE_NAME"
      else
        color "$YELLOW" "  - $repo - could not checkout $base_branch"
      fi
    fi
  done

  echo ""
  echo "Done. Run 'tool/repo status' to verify."
}

# Command: checkout
# Create/checkout feature branch across repos
# IMPORTANT: New branches are always created from the latest typedb/<base_branch>
cmd_checkout() {
  local feature="$1"
  shift
  local repos=("$@")

  if [ ${#repos[@]} -eq 0 ]; then
    echo "Error: No repos specified"
    echo "Usage: repo checkout <feature> <repo1> [repo2...]"
    exit 1
  fi

  echo "Checking out feature branch: $feature"
  echo ""

  for repo in "${repos[@]}"; do
    if ! validate_repo "$repo"; then
      color "$RED" "  ✗ $repo - not a valid submodule"
      continue
    fi

    local repo_path="$REPOS_DIR/$repo"
    local current_branch
    current_branch=$(get_branch "$repo")
    local base_branch
    base_branch=$(get_base_branch "$repo")

    if [ "$current_branch" = "$feature" ]; then
      color "$BLUE" "  ● $repo - already on $feature"
    elif git -C "$repo_path" show-ref --verify --quiet "refs/heads/$feature" 2>/dev/null; then
      git -C "$repo_path" checkout "$feature" &>/dev/null
      color "$GREEN" "  ✓ $repo - switched to existing $feature"
    else
      # Fetch latest and create branch from typedb/<base_branch>
      if ! git -C "$repo_path" fetch "$REMOTE_NAME" "$base_branch" &>/dev/null; then
        color "$RED" "  ✗ $repo - failed to fetch $REMOTE_NAME/$base_branch"
        continue
      fi
      if git -C "$repo_path" checkout -b "$feature" "$REMOTE_NAME/$base_branch" &>/dev/null; then
        color "$GREEN" "  ✓ $repo - created $feature from $REMOTE_NAME/$base_branch"
      else
        color "$RED" "  ✗ $repo - failed to create branch from $REMOTE_NAME/$base_branch"
      fi
    fi
  done

  echo ""
  echo "Done."
}

# Command: switch
# Switch repos to existing feature branch (fetches from remote if needed)
cmd_switch() {
  local feature="$1"
  shift
  local repos=("$@")

  if [ ${#repos[@]} -eq 0 ]; then
    echo "Error: No repos specified"
    echo "Usage: repo switch <feature> <repo1> [repo2...]"
    exit 1
  fi

  echo "Switching to feature branch: $feature"
  echo ""

  for repo in "${repos[@]}"; do
    if ! validate_repo "$repo"; then
      color "$RED" "  ✗ $repo - not a valid submodule"
      continue
    fi

    local repo_path="$REPOS_DIR/$repo"
    local current_branch
    current_branch=$(get_branch "$repo")

    if [ "$current_branch" = "$feature" ]; then
      color "$BLUE" "  ● $repo - already on $feature"
    elif git -C "$repo_path" show-ref --verify --quiet "refs/heads/$feature" 2>/dev/null; then
      git -C "$repo_path" checkout "$feature" &>/dev/null
      color "$GREEN" "  ✓ $repo - switched to $feature"
    else
      # Try to fetch and checkout from remote
      if git -C "$repo_path" fetch "$REMOTE_NAME" "$feature" &>/dev/null 2>&1 && \
         git -C "$repo_path" checkout -b "$feature" "$REMOTE_NAME/$feature" &>/dev/null 2>&1; then
        color "$GREEN" "  ✓ $repo - fetched and switched to $feature"
      else
        color "$RED" "  ✗ $repo - branch '$feature' not found"
      fi
    fi
  done

  echo ""
  echo "Done."
}

# Command: status
# Show status of all repos
cmd_status() {
  local filter_feature=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --feature)
        filter_feature="$2"
        shift 2
        ;;
      *)
        shift
        ;;
    esac
  done

  if [ -n "$filter_feature" ]; then
    echo "Status for feature: $filter_feature"
  else
    echo "Repository Status"
  fi
  echo "================="
  echo ""

  printf "%-20s %-20s %-8s %-12s\n" "REPO" "BRANCH" "CLEAN" "AHEAD/BEHIND"
  printf "%-20s %-20s %-8s %-12s\n" "----" "------" "-----" "------------"

  for repo in "${ALL_REPOS[@]}"; do
    if ! validate_repo "$repo"; then
      continue
    fi

    local branch
    branch=$(get_branch "$repo")

    # If filtering by feature, skip repos not on that branch or master
    if [ -n "$filter_feature" ]; then
      if [ "$branch" != "$filter_feature" ] && [ "$branch" != "master" ]; then
        continue
      fi
    fi

    local clean_status
    if is_clean "$repo"; then
      clean_status="yes"
    else
      local modified
      modified=$(get_modified_count "$repo")
      clean_status="${modified}m"
    fi

    local ahead_behind
    ahead_behind=$(get_ahead_behind "$repo")
    local ahead behind
    ahead=$(echo "$ahead_behind" | awk '{print $1}')
    behind=$(echo "$ahead_behind" | awk '{print $2}')
    local sync_status="-"
    if [ "$ahead" != "0" ] || [ "$behind" != "0" ]; then
      sync_status="+${ahead}/-${behind}"
    fi

    # Color the branch based on whether it matches feature or is master
    local branch_display="$branch"
    if [ -n "$filter_feature" ] && [ "$branch" = "$filter_feature" ]; then
      branch_display=$(color "$GREEN" "$branch")
    elif [ "$branch" = "master" ]; then
      branch_display=$(color "$BLUE" "$branch")
    else
      branch_display=$(color "$YELLOW" "$branch")
    fi

    printf "%-20s %-20s %-8s %-12s\n" "$repo" "$branch" "$clean_status" "$sync_status"
  done

  echo ""
}

# Command: reset
# Reset repos back to their base branch (from CLAUDE.md, usually master)
# Fetches latest from typedb remote first
cmd_reset() {
  local repos=("$@")

  if [ ${#repos[@]} -eq 0 ]; then
    repos=("${ALL_REPOS[@]}")
  fi

  echo "Resetting to base branches (fetching latest from $REMOTE_NAME)"
  echo ""

  for repo in "${repos[@]}"; do
    if ! validate_repo "$repo"; then
      color "$RED" "  ✗ $repo - not a valid submodule"
      continue
    fi

    local repo_path="$REPOS_DIR/$repo"
    local current_branch
    current_branch=$(get_branch "$repo")
    local base_branch
    base_branch=$(get_base_branch "$repo")

    # Fetch latest base branch
    if ! git -C "$repo_path" fetch "$REMOTE_NAME" "$base_branch" &>/dev/null; then
      color "$YELLOW" "  - $repo - failed to fetch $REMOTE_NAME/$base_branch"
      # Still try to checkout if possible
    fi

    if [ "$current_branch" = "$base_branch" ]; then
      # Already on base branch, just sync with remote
      if git -C "$repo_path" reset --hard "$REMOTE_NAME/$base_branch" &>/dev/null; then
        color "$BLUE" "  ● $repo - already on $base_branch (synced with $REMOTE_NAME)"
      else
        color "$BLUE" "  ● $repo - already on $base_branch"
      fi
    else
      if git -C "$repo_path" checkout "$base_branch" &>/dev/null; then
        if git -C "$repo_path" reset --hard "$REMOTE_NAME/$base_branch" &>/dev/null; then
          color "$GREEN" "  ✓ $repo - reset to $base_branch (was: $current_branch, synced with $REMOTE_NAME)"
        else
          color "$GREEN" "  ✓ $repo - reset to $base_branch (was: $current_branch)"
        fi
      else
        color "$RED" "  ✗ $repo - failed to checkout $base_branch"
      fi
    fi
  done

  echo ""
  echo "Done."
}

# Command: fetch
# Fetch latest from remote for specified repos
cmd_fetch() {
  local repos=("$@")

  if [ ${#repos[@]} -eq 0 ]; then
    repos=("${ALL_REPOS[@]}")
  fi

  echo "Fetching from remote: $REMOTE_NAME"
  echo ""

  for repo in "${repos[@]}"; do
    if ! validate_repo "$repo"; then
      color "$RED" "  ✗ $repo - not a valid submodule"
      continue
    fi

    if git -C "$REPOS_DIR/$repo" fetch "$REMOTE_NAME" &>/dev/null; then
      color "$GREEN" "  ✓ $repo"
    else
      color "$RED" "  ✗ $repo - fetch failed"
    fi
  done

  echo ""
  echo "Done."
}

# Command: pull
# Fetch and fast-forward current branch to latest from remote
cmd_pull() {
  local repos=("$@")

  if [ ${#repos[@]} -eq 0 ]; then
    repos=("${ALL_REPOS[@]}")
  fi

  echo "Pulling latest from remote: $REMOTE_NAME"
  echo ""

  for repo in "${repos[@]}"; do
    if ! validate_repo "$repo"; then
      color "$RED" "  ✗ $repo - not a valid submodule"
      continue
    fi

    local repo_path="$REPOS_DIR/$repo"
    local branch
    branch=$(get_branch "$repo")

    if [ "$branch" = "HEAD" ]; then
      color "$YELLOW" "  - $repo - detached HEAD, skipping"
      continue
    fi

    # Check for uncommitted changes
    if ! is_clean "$repo"; then
      color "$YELLOW" "  - $repo - has uncommitted changes, skipping"
      continue
    fi

    # Fetch the current branch from remote
    if ! git -C "$repo_path" fetch "$REMOTE_NAME" "$branch" &>/dev/null 2>&1; then
      # Branch might not exist on remote (e.g., local feature branch)
      color "$BLUE" "  ● $repo - $branch (no remote tracking)"
      continue
    fi

    # Check if remote branch exists
    if ! git -C "$repo_path" rev-parse "$REMOTE_NAME/$branch" &>/dev/null; then
      color "$BLUE" "  ● $repo - $branch (no remote tracking)"
      continue
    fi

    # Try to fast-forward merge
    local before_sha after_sha
    before_sha=$(git -C "$repo_path" rev-parse HEAD)

    if git -C "$repo_path" merge --ff-only "$REMOTE_NAME/$branch" &>/dev/null 2>&1; then
      after_sha=$(git -C "$repo_path" rev-parse HEAD)
      if [ "$before_sha" = "$after_sha" ]; then
        color "$BLUE" "  ● $repo - $branch (already up to date)"
      else
        local commits_pulled
        commits_pulled=$(git -C "$repo_path" rev-list --count "$before_sha..$after_sha")
        color "$GREEN" "  ✓ $repo - $branch (pulled $commits_pulled commit(s))"
      fi
    else
      color "$YELLOW" "  - $repo - $branch (cannot fast-forward, manual merge needed)"
    fi
  done

  echo ""
  echo "Done."
}

# Command: commit
# Commit changes across all repos on a feature branch
cmd_commit() {
  if [ $# -lt 2 ]; then
    echo "Error: commit requires feature name and commit message"
    echo "Usage: repo commit <feature> \"<message>\""
    exit 1
  fi

  local feature="$1"
  shift
  local message="$*"

  if [ "$feature" = "master" ]; then
    echo "Error: Cannot use 'master' as feature name for batch commits"
    echo "Commit to master branches individually in each repository"
    exit 1
  fi

  echo "Committing to feature branch: $feature"
  echo "Message: $message"
  echo ""

  local committed=0
  local skipped=0

  for repo in "${ALL_REPOS[@]}"; do
    if ! validate_repo "$repo"; then
      continue
    fi

    local repo_path="$REPOS_DIR/$repo"
    local branch
    branch=$(get_branch "$repo")

    # Skip repos not on the feature branch
    if [ "$branch" != "$feature" ]; then
      continue
    fi

    # Check if repo has changes
    if is_clean "$repo"; then
      color "$BLUE" "  ● $repo - no changes to commit"
      ((skipped++))
      continue
    fi

    # Stage all changes and commit
    local modified
    modified=$(get_modified_count "$repo")

    if git -C "$repo_path" add -A && git -C "$repo_path" commit -m "$message" &>/dev/null; then
      color "$GREEN" "  ✓ $repo - committed ($modified files)"
      ((committed++))
    else
      color "$RED" "  ✗ $repo - commit failed"
    fi
  done

  echo ""
  if [ $committed -eq 0 ] && [ $skipped -eq 0 ]; then
    echo "No repositories found on branch '$feature'"
    echo "Use 'tool/repo checkout $feature <repos...>' first"
  else
    echo "Done. Committed: $committed, Skipped (clean): $skipped"
  fi
}

# Command: push
# Push feature branch to fork remote and show PR links
cmd_push() {
  if [ $# -lt 2 ]; then
    echo "Error: push requires fork remote name and feature branch"
    echo "Usage: repo push <fork-remote> <feature>"
    exit 1
  fi

  local fork_remote="$1"
  local feature="$2"

  if [ "$feature" = "master" ]; then
    echo "Error: Cannot push 'master' as a feature branch"
    exit 1
  fi

  echo "Pushing feature branch '$feature' to remote '$fork_remote'"
  echo ""

  local pushed_repos=()
  local pr_links=()
  local missing_claude_md=()

  for repo in "${ALL_REPOS[@]}"; do
    if ! validate_repo "$repo"; then
      continue
    fi

    local repo_path="$REPOS_DIR/$repo"
    local branch
    branch=$(get_branch "$repo")

    # Skip repos not on the feature branch
    if [ "$branch" != "$feature" ]; then
      continue
    fi

    # Check if fork remote exists
    if ! git -C "$repo_path" remote get-url "$fork_remote" &>/dev/null; then
      color "$YELLOW" "  - $repo - remote '$fork_remote' not configured (add with: git remote add $fork_remote git@github.com:$fork_remote/$repo.git)"
      continue
    fi

    # Check if repo has a CLAUDE.md with base branch
    local claude_md="$repo_path/CLAUDE.md"
    local base_branch
    base_branch=$(get_base_branch "$repo")

    if [ ! -f "$claude_md" ]; then
      missing_claude_md+=("$repo")
    elif [ "$base_branch" = "master" ]; then
      # Check if CLAUDE.md exists but doesn't have base branch specified
      if ! grep -qiE "(base[_ ]?branch)\s*\**\s*:" "$claude_md" 2>/dev/null; then
        missing_claude_md+=("$repo (CLAUDE.md exists but no base branch specified)")
      fi
    fi

    # Push to fork remote
    if git -C "$repo_path" push -u "$fork_remote" "$feature" 2>/dev/null; then
      color "$GREEN" "  ✓ $repo - pushed to $fork_remote/$feature"
      pushed_repos+=("$repo")

      # Generate PR link
      local pr_url="https://github.com/typedb/$repo/compare/${base_branch}...$fork_remote:$feature?expand=1"
      pr_links+=("$repo|$base_branch|$pr_url")
    else
      color "$RED" "  ✗ $repo - push failed"
    fi
  done

  echo ""

  # Show PR links
  if [ ${#pushed_repos[@]} -gt 0 ]; then
    echo "Create Pull Requests:"
    echo "====================="
    echo ""
    for link_info in "${pr_links[@]}"; do
      local repo_name base pr_url
      repo_name=$(echo "$link_info" | cut -d'|' -f1)
      base=$(echo "$link_info" | cut -d'|' -f2)
      pr_url=$(echo "$link_info" | cut -d'|' -f3)
      echo "  $repo_name (base: $base):"
      echo "    $pr_url"
      echo ""
    done
  fi

  # Warn about missing CLAUDE.md or base branch
  if [ ${#missing_claude_md[@]} -gt 0 ]; then
    echo ""
    color "$YELLOW" "Warning: The following repos need CLAUDE.md with base branch specification:"
    for repo in "${missing_claude_md[@]}"; do
      color "$YELLOW" "  - $repo"
    done
    echo ""
  fi

  if [ ${#pushed_repos[@]} -eq 0 ]; then
    echo "No repositories found on branch '$feature'"
    echo "Use 'tool/repo checkout $feature <repos...>' first"
  else
    echo "Done. Pushed ${#pushed_repos[@]} repo(s)."
  fi
}

# Command: list
# List all repos
cmd_list() {
  echo "Primary Repositories:"
  echo "  typedb typedb-driver typeql typedb-protocol typedb-console typedb-studio"
  echo ""
  echo "Private Repositories:"
  echo "  typedb-cluster typedb-cloud typedb-cloud-infrastructure"
  echo ""
  echo "Secondary Repositories:"
  echo "  dependencies bazel-distribution typedb-behaviour typedb-docs typedb-examples typedb-web"
}

# Show help
show_help() {
  cat << 'EOF'
TypeDB Multi-Repo Tool

Usage: repo <command> [options]

Commands:
  init [repo1] [repo2...]                 Initialize submodules, configure remotes, fetch & checkout base branches
  checkout <feature> <repo1> [repo2...]   Create feature branch from typedb/<base_branch> (fetches latest first)
  switch <feature> <repo1> [repo2...]     Switch to existing feature branch
  status [--feature <name>]               Show status of all repos
  commit <feature> "<message>"            Commit changes in all repos on feature branch
  push <fork-remote> <feature>            Push feature branch to fork and show PR links
  reset [repo1] [repo2...]                Reset repos to base branch (all if none specified)
  fetch [repo1] [repo2...]                Fetch from remote (all if none specified)
  pull [repo1] [repo2...]                 Pull (fetch + fast-forward) current branches (all if none specified)
  list                                    List all available repos

Notes:
  - Base branches are read from each repo's CLAUDE.md (usually 'master')
  - New branches are ALWAYS created from the latest typedb/<base_branch>
  - Reset fetches and syncs with typedb/<base_branch>

Examples:
  repo init                               # Initialize all submodules
  repo init typedb typeql                 # Initialize specific repos only
  repo checkout new-feature typedb typeql typedb-driver
  repo switch existing-feature typedb typeql
  repo status --feature new-feature
  repo commit new-feature "Add new query type support"
  repo push myusername new-feature        # Push to fork and get PR links
  repo reset                              # Reset all repos to base branches
  repo reset typedb typeql typedb-driver
  repo fetch
  repo list
EOF
}

# Main command dispatch
main() {
  if [ $# -eq 0 ]; then
    show_help
    exit 0
  fi

  local cmd="$1"
  shift

  case "$cmd" in
    init)
      cmd_init "$@"
      ;;
    checkout)
      if [ $# -lt 2 ]; then
        echo "Error: checkout requires feature name and at least one repo"
        echo "Usage: repo checkout <feature> <repo1> [repo2...]"
        exit 1
      fi
      cmd_checkout "$@"
      ;;
    switch)
      if [ $# -lt 2 ]; then
        echo "Error: switch requires feature name and at least one repo"
        echo "Usage: repo switch <feature> <repo1> [repo2...]"
        exit 1
      fi
      cmd_switch "$@"
      ;;
    status)
      cmd_status "$@"
      ;;
    commit)
      cmd_commit "$@"
      ;;
    push)
      if [ $# -lt 2 ]; then
        echo "Error: push requires fork remote name and feature branch"
        echo "Usage: repo push <fork-remote> <feature>"
        exit 1
      fi
      cmd_push "$@"
      ;;
    reset)
      cmd_reset "$@"
      ;;
    fetch)
      cmd_fetch "$@"
      ;;
    pull)
      cmd_pull "$@"
      ;;
    list)
      cmd_list
      ;;
    help|--help|-h)
      show_help
      ;;
    *)
      echo "Error: Unknown command: $cmd"
      echo ""
      show_help
      exit 1
      ;;
  esac
}

main "$@"
